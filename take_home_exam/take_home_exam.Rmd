---
title: "Untitled"
author: "Felix Seo"
date: "2023-10-11"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(mvtnorm)
library(tidyverse)
```

```{r}
# loading the data
data_toxic <- read_delim("../data/toxic.csv", delim = ",")

```


```{r}
# Task 5 b

mean_vec <- c(0, 10)
cov_mat <- matrix(c(4, 12, 12, 100), nrow = 2)

# x and y is vector of values. 
unnorm_post <- function(alpha, beta, x, y, n){
  prob_pi <- 1 / (1 + exp( - (alpha + beta * x)))
  log_lik <- dbinom(y, n, prob_pi, log = TRUE) # log=TRUE gives the log like.
  log_prior <- dmvnorm(c(alpha, beta), mean_vec, cov_mat, log = TRUE)
  log_post <- sum(log_lik) + log_prior
  log_post 
}

seq_alpha <- seq(-2.5, 5, 0.1)
seq_beta <- seq(-1, 30, 1)

data.frame(
  "alpha" = rep(seq_alpha, each = length(seq_beta)),
  "beta" = rep(seq_beta, times = length(seq_alpha))
) %>% 
  mutate(
    un_post = mapply(function(x, y) unnorm_post(x, y, c(1,1), c(1,1), 5),
                     alpha, 
                     beta)
  ) %>% # our function not vectorized, not work with mutate.
  ggplot(aes(x = alpha, y = beta, z = un_post)) +
  geom_contour_filled()


```

```{r}
# Task 5 c

# outputs a vector of sequences of theta as 
# c(theta_0, theta_1, ...) = c(alpha_0, beta_0, alpha_1, beta_1, ...).
MH_alg <- function(theta_init, iter, x, y, n = 5){
  prop_cov <- matrix(c(1, 0, 0, 5), nrow = 2)
  theta_seq <- c(theta_init) # prop_mean_seq
  theta <- theta_init       # prop_mean
  #alpha_seq <- c(theta_init[1])
  #beta_seq <- c(theta_int[2])
  
  for (i in 1:iter) {
    prop_sample <- rmvnorm(1, theta, prop_cov) %>% as.vector() # vector easy to work with
    prop_theta <- dmvnorm(theta, prop_sample, prop_cov) # q(theta^{t-1} | theta^{star})
    prop_theta_star <- dmvnorm(prop_sample, theta, prop_cov) # q(theta^{star} | theta^{t-1})
    
    post_theta_star <- unnorm_post(theta[1], theta[2], x, y, n)
    post_theta <- unnorm_post(prop_sample[1], prop_sample[2], x, y, n)
    
    post_fraction <- exp(post_theta_star - post_theta)
    prop_fraction <- prop_theta / prop_theta_star
    accept_prob <- min(1, post_fraction * prop_fraction) # multiplication since calc prop above.
    
    unif <- runif(1, 0, 1)
    if (unif <= accept_prob) {
      theta <- prop_sample
      theta_seq <- c(theta_seq, prop_sample)
    } else if (unif > accept_prob) {
      theta_seq <- c(theta_seq, theta)
    } 
  }
  
  theta_seq
}


```

```{r}
# Task 5 d 

samples <- MH_alg(c(-2.5, 0), 10000, data_toxic$x, data_toxic$y) 

samples %>% 
  as.data.frame()


```




```{r, eval = FALSE}
# testing area 


MH_alg <- function(theta_init, iter, x, y, n = 5){
  prop_cov <- matrix(c(1, 0, 0, 5), nrow = 2)
  theta_seq <- c(theta_init) # prop_mean_seq
  theta <- theta_init       # prop_mean
  
  for (i in 1:iter) {
    prop_sample <- rmvnorm(1, theta, prop_cov) %>% as.vector() # vector easy to work with
    prop_theta <- dmvnorm(theta, prop_sample, prop_cov) # q(theta^{t-1} | theta^{star})
    prop_theta_star <- dmvnorm(prop_sample, theta, prop_cov) # q(theta^{star} | theta^{t-1})
    
    post_theta_star <- unnorm_post(prop_sample[1], prop_sample[2], x, y, n)
    post_theta <- unnorm_post(theta[1], theta[2], x, y, n)
    
    post_fraction <- exp(post_theta_star - post_theta)
    prop_fraction <- prop_theta / prop_theta_star
    
    if (is.na(prop_fraction) == TRUE) {
      stop("prop_fraction is wrong")
    } else if (is.na(post_fraction) == TRUE) {
      stop("post_fraction is wrong")
    }
    
    accept_prob <- min(1, post_fraction * prop_fraction) # multiplication since calc prop above.
    
    unif <- runif(1, 0, 1)
    if (unif <= accept_prob) {
      theta <- prop_sample
      theta_seq <- c(theta_seq, prop_sample)
    } else if (unif > accept_prob) {
      theta_seq <- c(theta_seq, theta)
    } 
  }
  
  theta_seq
}

MH_alg(c(-2.5, 0), 3000, data_toxic$x, data_toxic$y)

```

