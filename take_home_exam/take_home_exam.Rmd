---
title: "Untitled"
author: "Felix Seo"
date: "2023-10-11"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(mvtnorm)
library(tidyverse)
library(rstan)
```

```{r}
# loading the data
data_toxic <- read_delim("../data/toxic.csv", delim = ",")
data_returns <- read_delim("../data/returns.csv", delim = ",") %>% 
  mutate(across(contains("Stock"), ~as.numeric(.x)))

```


```{r}
# Task 5 b

mean_vec <- c(0, 10)
cov_mat <- matrix(c(4, 12, 12, 100), nrow = 2)

# x and y is vector of values. 
unnorm_post <- function(alpha, beta, x, y, n){
  prob_pi <- 1 / (1 + exp( - (alpha + beta * x)))
  log_lik <- dbinom(y, n, prob_pi, log = TRUE) # log=TRUE gives the log like.
  log_prior <- dmvnorm(c(alpha, beta), mean_vec, cov_mat, log = TRUE)
  log_post <- sum(log_lik) + log_prior
  log_post 
}

seq_alpha <- seq(-2.5, 5, 0.1)
seq_beta <- seq(-1, 30, 1)


data.frame(
  "alpha" = rep(seq_alpha, each = length(seq_beta)),
  "beta" = rep(seq_beta, times = length(seq_alpha))
) %>% 
  mutate(
    un_post = mapply(function(x, y) unnorm_post(x, y, data_toxic$x, data_toxic$y, 5),
                     alpha, 
                     beta)
  ) %>% # our function not vectorized, not work with mutate.
  ggplot(aes(x = alpha, y = beta, z = un_post)) +
  geom_contour_filled()
```

```{r}
# Task 5 c

# outputs a vector of sequences of theta as 
# c(theta_0, theta_1, ...) = c(alpha_0, beta_0, alpha_1, beta_1, ...).
MH_alg <- function(alpha_init, beta_init, x, y, n = 5, iter){
  prop_cov <- matrix(c(1, 0, 0, 5), nrow = 2)
  #theta_seq <- c(theta_init)
  #theta <- theta_init     
  alpha <- alpha_init
  beta <- beta_init
  alpha_seq <- c(alpha_init)
  beta_seq <- c(beta_init)
  
  for (i in 1:iter) {
    prop_sample <- rmvnorm(1, c(alpha, beta), prop_cov) %>% as.vector() # vector easy to work with
    prop_theta <- dmvnorm(c(alpha, beta), prop_sample, prop_cov) # q(theta^{t-1} | theta^{star})
    prop_theta_star <- dmvnorm(prop_sample, c(alpha, beta), prop_cov) # q(theta^{star} | theta^{t-1})
    
    post_theta_star <- unnorm_post(prop_sample[1], prop_sample[2] , x, y, n)
    post_theta <- unnorm_post(alpha, beta, x, y, n) # f(theta^{t-1} | x)
    
    post_fraction <- exp(post_theta_star - post_theta)
    prop_fraction <- prop_theta / prop_theta_star
    accept_prob <- min(1, post_fraction * prop_fraction) # multiplication since calc prop above.
    
    unif <- runif(1, 0, 1)
    if (unif <= accept_prob) {
      alpha <- prop_sample[1]
      beta <- prop_sample[2]
      alpha_seq <- c(alpha_seq, prop_sample[1])
      beta_seq <- c(beta_seq, prop_sample[2])
    } else if (unif > accept_prob) {
      alpha_seq <- c(alpha_seq, alpha)
      beta_seq <- c(beta_seq, beta)
    } 
  }

  data.frame("alpha" = alpha_seq, "beta" = beta_seq)
}


```

```{r}
# Task 5 d 

samples <- MH_alg(-2.5, 0, data_toxic$x, data_toxic$y, iter = 10000) 

samples %>% 
  {mutate(., time = seq(0, length(.$alpha) - 1, 1))} %>% 
  ggplot(aes(x = time, y = alpha)) +
  geom_line()

samples %>% 
  {mutate(., time = seq(0, length(.$alpha) - 1, 1))} %>% 
  ggplot(aes(x = time, y = beta)) +
  geom_line()

samples %>% 
  pivot_longer(cols = everything(), names_to = c("parameter"), values_to = "value") %>% 
  ggplot(aes(x = value, y = after_stat(density))) +
  geom_histogram(bins = 100, color = "black", fill = "white") + 
  facet_wrap(vars(parameter), scales = "free_x")


```




```{r, eval = FALSE}
# testing area partly

#######################
MH_alg <- function(theta_init, iter, x, y, n = 5){
  prop_cov <- matrix(c(1, 0, 0, 5), nrow = 2)
  theta_seq <- c(theta_init) # prop_mean_seq
  theta <- theta_init       # prop_mean
  
  for (i in 1:iter) {
    prop_sample <- rmvnorm(1, theta, prop_cov) %>% as.vector() # vector easy to work with
    prop_theta <- dmvnorm(theta, prop_sample, prop_cov) # q(theta^{t-1} | theta^{star})
    prop_theta_star <- dmvnorm(prop_sample, theta, prop_cov) # q(theta^{star} | theta^{t-1})
    
    post_theta_star <- unnorm_post(prop_sample[1], prop_sample[2], x, y, n)
    post_theta <- unnorm_post(theta[1], theta[2], x, y, n)
    
    post_fraction <- exp(post_theta_star - post_theta)
    prop_fraction <- prop_theta / prop_theta_star
    
    if (is.na(prop_fraction) == TRUE) {
      stop("prop_fraction is wrong")
    } else if (is.na(post_fraction) == TRUE) {
      stop("post_fraction is wrong")
    }
    
    accept_prob <- min(1, post_fraction * prop_fraction) # multiplication since calc prop above.
    
    unif <- runif(1, 0, 1)
    if (unif <= accept_prob) {
      theta <- prop_sample
      theta_seq <- c(theta_seq, prop_sample)
    } else if (unif > accept_prob) {
      theta_seq <- c(theta_seq, theta)
    } 
  }
  
  theta_seq
}

MH_alg(c(-2.5, 0), 3000, data_toxic$x, data_toxic$y)



#####################


test_alpha <- samples %>% select(alpha) %>% slice_sample(n = 2432) %>% {.$alpha}
test_beta <- samples %>% select(beta) %>% slice_sample(n = 2432) %>% {.$beta}

data.frame(
  "alpha" = rep(seq_alpha, each = length(seq_beta)),
  "beta" = rep(seq_beta, times = length(seq_alpha))
) %>% 
  mutate(
    un_post = mapply(function(x, y) unnorm_post(x, y, data_toxic$x, data_toxic$y, 5),
                     alpha, 
                     beta)
  ) %>% # our function not vectorized, not work with mutate.
  ggplot(aes(x = alpha, y = beta, z = un_post)) +
  geom_contour_filled() +
  geom_point(data = NULL, aes(x = test_alpha, y = test_beta))
```

```{r}
# Task 6 a

data_returns_2 <- data_returns %>% 
  select(-Date) %>% 
  pivot_longer(everything(), names_to = "stock", values_to = "returns") 

# Density histograms for the stocks  
data_returns_2 %>% 
  ggplot(aes(x = returns, y = after_stat(density))) +
  geom_histogram(bins = 100) + 
  facet_wrap(~ stock)

data_returns_2 %>% 
  ggplot(aes(x = stock, y = returns)) +
  geom_boxplot()
  
data_returns_2 %>% 
  group_by(stock) %>% 
  summarise(
    mean = mean(returns), 
    variance = var(returns), 
    median = median(returns)
  )

```




```{r}
# Task 6 b

P_alpha <- matrix(c(1, 0.5, 0.5, 0, 0, 0, 
                    0.5, 1, 0.5, 0, 0, 0, 
                    0.5, 0.5, 1, 0, 0, 0,
                    rep(0, 18)
                  ),
                  nrow = 6) 

P_beta <- matrix(c(0, 0, 0, 0, 0, 0, 
                   0, 0, 0, 0, 0, 0,
                   0, 0, 0, 0, 0, 0,
                   0, 0, 0, 1, 0.5, 0.5, 
                   0, 0, 0, 0.5, 1, 0.5,
                   0, 0, 0, 0.5, 0.5, 1
                  ),
                  nrow = 6)

data_stock <- data_returns %>% select(!Date) %>% as.matrix()

model_data <- list(
  "N" = length(data_returns$Date),
  "K" = 6,
  "Y" = data_stock,
  "vec_1" = rep(1, 6),
  "identity_mat" = diag(1, 6), 
  "P_alpha" = P_alpha * 100, 
  "P_beta" = P_beta * 100
  )

model_fit <- stan(
  "stan_model_6.stan",
  data = model_data,
  chains = 4, 
  iter = 5000, 
  warmup = 2000,
  cores = 4
  )

sampling(stan_model("stan_model_6.stan"), data = list(
  "N" = length(data_returns$Date),
  "K" = 6,
  "Y" = data_stock,
  "vec_1" = rep(1, 6),
  "identity_mat" = diag(1, 6), 
  "P_alpha" = P_alpha * 100, 
  "P_beta" = P_beta * 100
  ),
  iter = 10000
)
```

```{r}
#rstan::extract(model_fit, pars = c("mu", "cov_mat")) %>% 
#  as.data.frame() %>% 
  

traceplot(model_fit, pars = "y_rep")

rmvnorm(
  10000, 
  mean = 0.1*c(-0.07, -0.06, 0.03, -0.02, -0.05, 0.03), 
  sigma = matrix(
    0.01*c(0.56, 0.28, 0.28, 0, 0, 0, 
      0.28, 0.56, 0.28, 0, 0, 0,
      0.28, 0.28, 0.56, 0, 0, 0,
      0, 0, 0, 0.6, 0.3, 0.3, 
      0, 0, 0, 0.3, 0.6, 0.3,
      0, 0, 0, 0.3, 0.3, 0.6 
    ),
    nrow = 6
  )
) %>% 
  as.data.frame() %>% 
  mutate(mean1 = mean(V1), var1 = var(V1))
```

